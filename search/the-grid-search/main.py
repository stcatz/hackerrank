'''
Problem Statement

Given a 2D array of digits, try to find the location of a given 2D pattern of digits within it. For example, consider the following 2D matrix.

1234567890  
0987654321  
1111111111  
1111111111  
2222222222  
If we need to look for the following 2D pattern within it:

876543  
111111  
111111
If we scan through the original array, we observe, that 2D pattern begins from the second row and the third column of the larger grid (the 8 in the second row and third column of the larger grid, is the top-left corner of the pattern we are searching for).

So, a 2D pattern of digits P is said to be present in a larger grid G, if the latter contains a contiguous, rectangular 2D grid of digits matching with the pattern P; similar to the example shown above.

Input Format 
The first line contains an integer T, which is the number of tests. T tests follow and the structure of each test is described below: 
The first line contains 2 space separated integers R and C indicating the number of rows and columns in the grid G. 
This is followed by R lines, each with a string of C digits each; which represent the grid G. 
The second line contains 2 tab separated integers r and c indicating the number of rows and columns in the pattern grid P. 
This is followed by r lines, each with a string of c digits each; which represent the pattern P.

Constraints 
1<=T<=5 
1<=R,r,C,c<=1000 
1<=r<=R 
1<=c<=C

Test Case Generation 
Each individual test has been generated by first specifying the size (R and C) of the large 2D matrix, and then randomly generating the digits in it. A limited number of digits in the larger matrix may be changed by the problem setter (no more than 5% of the total number of digits in the marix). So the larger 2D matrix is almost-random. The pattern matrix has been manually-curated by the problem setter.

Output Format 
Display 'YES' or 'NO', depending on whether (or not) you find that the larger grid G contains the rectangular pattern P. The evaluation will be case sensitive.

Sample Input

2
10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
Sample Output

YES
NO
Explanation

The first test in the input file is:

10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
As one may see, the given 2D grid is indeed present in the larger grid, as marked in bold below.

7283455864  
6731158619  
8988242643  
3830589324  
2229505813  
5633845374  
6473530293  
7053106601  
0834282956  
4607924137  
The second test in the input file is:

15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
The search pattern is:

99
99
This cannot be found in the larger grid.

Copyright (c) 2015 HackerRank.
All Rights Reserved
Suggest Edits
748 hackers have submitted code
Share

Download PDF
Current Buffer (saved locally, editable)     

'''

t = int(raw_input())

def find_all(str1, str2):
	result = []
	found = str1.find(str2)
	start = 0
	while found != -1:
		result.append(found)
		if len(result)!=0:
			start = result[len(result)-1] + 1
		found = str1[start:len(str1)].find(str2)
		if found == -1:
			break
		elif len(result) != 0:
			found += start
		
	if len(result) == 0:
		return -1
	else:
		return result

def calc(i1,j1, ar1, i2,j2, ar2):
	flag = False
	for k1 in range(i1):
		match = find_all(ar1[k1], ar2[0])
		if match == -1:
			continue
		else:
			for x in match:
				#print k1, match
				same_count = 1
				for incr in range(1, len(ar2)):
					if ar1[k1+incr][x:x+len(ar2[0])] != ar2[0+incr]:
						break
					else:
						same_count += 1
				if same_count == len(ar2):
					flag = True
	return flag


for x in xrange(t):
	R, C = map(int, raw_input().strip().split(" "))
	G = []
	for i in xrange(R):
		G.append(raw_input())

	r, c = map(int, raw_input().strip().split(" "))
	P = []
	for j in xrange(r):
		P.append(raw_input())

	if calc(R, C, G, r, c, P):
		print 'YES'
	else:
		print 'NO'

